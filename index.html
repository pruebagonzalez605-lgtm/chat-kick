<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <title>Chat en tiempo real â€” Kick</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://fonts.googleapis.com/css2?family=Baloo+Tammudu+2:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-dark: #0a0a0a;
      --bg-panel: #111111;
      --text: #e5e7eb;
      --muted: #888;
      --font: "Baloo Tammudu 2", system-ui, sans-serif;
    }

    * { box-sizing: border-box; }

    body {
      background: var(--bg-dark);
      color: var(--text);
      font-family: var(--font);
      margin: 0;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      min-height: 100vh;
      font-weight: 800;
    }

    #chat-section {
      width: 100%;
      max-width: 100%;
      margin: 0;
      background: transparent;
      border: none;
      border-radius: 0;
      box-shadow: none;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    .chat-header {
      background: transparent;
      border-bottom: none;
      padding: 0.5rem 1rem;
      text-align: left;
      color: var(--accent);
      font-weight: 700;
      font-size: 0.9rem;
      letter-spacing: 1px;
      display: none;
    }

    #channel-input-container {
      padding: 1rem;
      width: 100%;
      background: var(--bg-dark);
    }

    #chat {
      height: auto;
      overflow-y: auto;
      padding: 1rem;
      scrollbar-gutter: stable;
      scroll-behavior: smooth;
      background: transparent;
      flex-grow: 1;
      font-size: 20px;
      display: flex;
      flex-direction: column;
    }

    #chat::-webkit-scrollbar { width: 0px; }
    #chat::-webkit-scrollbar-track {
      background: transparent;
      border-radius: 6px;
    }
    #chat::-webkit-scrollbar-thumb {
      background: transparent;
      border-radius: 6px;
      box-shadow: none;
    }

    .msg {
      margin-bottom: 0.3rem;
      padding: 0;
      border-radius: 0;
      background: transparent;
      box-shadow: none;
      filter: drop-shadow(2px 2px 0.2rem black);
      transition: all 0.25s ease;
      opacity: 0;
      transform: translateY(5px);
      animation: fadeUp 0.3s ease forwards;
      line-height: 30px;
      display: block;
      word-wrap: break-word;
    }

    .msg:hover {
      background: transparent;
      transform: translateY(0);
      box-shadow: none;
    }

    .meta {
      display: inline;
      align-items: center;
      gap: 0;
      margin-bottom: 0;
      flex-wrap: nowrap;
    }

    .badges {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .badge-icon {
      width: 18px;
      height: 18px;
      border-radius: 3px;
      object-fit: contain;
      vertical-align: middle;
      margin-right: 3px;
      margin-bottom: 2px;
      display: inline-block;
    }

    .time { 
      color: var(--muted); 
      font-size: 0.8em;
      display: none;
    }
    .user {
      font-weight: 800;
      font-size: 1em;
      display: inline;
      align-items: center;
      gap: 2px;
    }
    
    .user::after {
      content: ': ';
    }

    .text {
      color: var(--text);
      line-height: 1.4;
      word-wrap: break-word;
      font-size: 1em;
      background: transparent;
      display: inline;
      margin-left: 0;
    }

    .emote {
      width: 32px;
      height: 32px;
      vertical-align: middle;
      margin: 0 3px;
      border-radius: 6px;
      max-width: 75px;
      max-height: 32px;
      margin-right: -3px;
    }

    .emote-zero-width {
      position: absolute;
      margin-left: -32px;
    }

    @keyframes fadeUp {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* Name paints - gradient text support */
    .name-paint {
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
  </style>
</head>
<body>

  <section id="chat-section">
    <div class="chat-header">ðŸ’¬ Chat en tiempo real</div>
    <div id="channel-input-container">
      <div style="display: flex; gap: 0.5rem; align-items: center; margin-bottom: 0.5rem;">
        <input type="text" id="channel-name-input" placeholder="Nombre del canal (ej: xqc)" 
               style="flex: 1; padding: 0.75rem 1rem; border-radius: 8px; border: none; background: #222; color: #fff; font-size: 16px; font-family: var(--font);">
        <button id="load-chat-btn" 
                style="padding: 0.75rem 1.5rem; border-radius: 8px; border: none; background: #53fc18; color: #000; font-size: 16px; font-weight: 700; cursor: pointer; font-family: var(--font);">
          Cargar Chat
        </button>
      </div>
      <div id="status-message" style="color: var(--muted); font-size: 14px; margin-bottom: 0.5rem;"></div>
      <div id="link-container" style="margin-top: 0.5rem; padding: 0.75rem; background: #1a1a1a; border-radius: 8px; display: none;">
        <label style="color: #53fc18; font-size: 14px; display: block; margin-bottom: 0.5rem; font-weight: 700;">ðŸ”— Link para compartir:</label>
        <div style="display: flex; gap: 0.5rem; align-items: center;">
          <input type="text" id="generated-link" readonly
                 style="flex: 1; padding: 0.5rem 1rem; border-radius: 8px; border: none; background: #0a0a0a; color: #53fc18; font-size: 13px; font-family: monospace;">
          <button id="copy-link-btn" 
                  style="padding: 0.5rem 1rem; border-radius: 8px; border: none; background: #333; color: #fff; font-size: 14px; cursor: pointer;">
            ðŸ“‹ Copiar
          </button>
          <button id="open-link-btn" 
                  style="padding: 0.5rem 1rem; border-radius: 8px; border: none; background: #53fc18; color: #000; font-size: 14px; font-weight: 700; cursor: pointer;">
            ðŸš€ Abrir
          </button>
        </div>
      </div>
    </div>
    <div id="chat" style="display: none;"></div>
  </section>

<script>
  // Proxy CORS
  const CORS_PROXY = "https://corsproxy.io/?";
  
  // WebSocket de Pusher para tiempo real
  const PUSHER_WS_URL = "wss://ws-us2.pusher.com/app/32cbd69e4b950bf97679?protocol=7&client=js&version=7.6.0&flash=false";
  
  let CHANNEL_ID = null;
  let CHATROOM_ID = null;
  let CHAT_URL = null;
  let currentChannel = null;
  let kickWS = null;
  const chatDiv = document.getElementById("chat");
  const inputContainer = document.getElementById("channel-input-container");
  const channelInput = document.getElementById("channel-name-input");
  const loadBtn = document.getElementById("load-chat-btn");
  const statusMsg = document.getElementById("status-message");
  const linkContainer = document.getElementById("link-container");
  const generatedLink = document.getElementById("generated-link");
  const copyLinkBtn = document.getElementById("copy-link-btn");
  const openLinkBtn = document.getElementById("open-link-btn");
  let messageIds = new Set();
  let pollInterval = null;
  let isFetching = false;
  let abortController = null;

  // ============ EMOTES & BADGES STORAGE ============
  let emotesData = {
    ffz: { global: {}, channel: {} },
    bttv: { global: {}, channel: {}, shared: {} },
    seventv: { global: {}, channel: {}, community: {} }  // â† Nuevo: para sets comunitarios Kick
  };

  let badgesData = {
    ffz: {},
    bttv: {},
    seventv: {},
    chatterino: {},
    ffzap: {}
  };

  let namePaints = {};

  // Kick badges locales
  const KICK_BADGES = {
    "moderator": "assets/mod.svg",
    "vip": "assets/vip.svg",
    "verified": "assets/verified.png",
    "broadcaster": "assets/broadcaster.png",
    "og": "assets/og.png",
    "subscriber": "assets/subscriber.png",
    "sub_gifter": "assets/sub_gifter.png",
    "founder": "assets/founder.png"
  };

  // Sets comunitarios populares de 7TV para Kick (actualizados 2026)
  const KICK_7TV_COMMUNITY_SETS = [
    "01HTTD778R000E3Y75DEQDXPKB",   // Variante Kick con canal carlogato
    // Puedes agregar mÃ¡s IDs buscando "Kick" en https://7tv.app/emote-sets
  ];

  // ============ FETCH HELPERS ============
  function getUrlParams() {
    const params = new URLSearchParams(window.location.search);
    return params.get("channel");
  }

  function generateLink(channelName) {
    const baseUrl = window.location.href.split("?")[0];
    return `${baseUrl}?channel=${encodeURIComponent(channelName)}`;
  }

  async function fetchDirect(url, timeout = 5000) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    try {
      const res = await fetch(url, {
        method: 'GET',
        headers: { 'Accept': 'application/json' },
        signal: controller.signal,
        cache: 'no-store',
        mode: 'cors'
      });
      clearTimeout(timeoutId);
      return await res.json();
    } catch (err) {
      clearTimeout(timeoutId);
      throw err;
    }
  }

  async function fetchWithProxy(url, timeout = 5000) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    try {
      const proxyUrl = CORS_PROXY + encodeURIComponent(url);
      const res = await fetch(proxyUrl, {
        signal: controller.signal,
        cache: 'no-store'
      });
      clearTimeout(timeoutId);
      return await res.json();
    } catch (err) {
      clearTimeout(timeoutId);
      throw err;
    }
  }

  async function raceFetch(url) {
    return Promise.race([
      fetchDirect(url).catch(() => null),
      fetchWithProxy(url).catch(() => null)
    ]).then(result => {
      if (result) return result;
      return fetchWithProxy(url);
    });
  }

  const smartFetch = raceFetch;

  // ============ LOAD FFZ EMOTES & BADGES ============
  async function loadFFZData(twitchId = null) {
    try {
      const globalData = await raceFetch("https://api.frankerfacez.com/v1/set/global");
      if (globalData.sets) {
        Object.values(globalData.sets).forEach(set => {
          set.emoticons.forEach(emote => {
            emotesData.ffz.global[emote.name] = {
              id: emote.id,
              url: `https://cdn.frankerfacez.com/emote/${emote.id}/2`,
              url2x: `https://cdn.frankerfacez.com/emote/${emote.id}/4`,
              width: emote.width,
              height: emote.height,
              zero_width: emote.css?.includes('transform') || false
            };
          });
        });
      }

      if (twitchId) {
        try {
          const roomData = await smartFetch(`https://api.frankerfacez.com/v1/room/id/${twitchId}`);
          if (roomData.sets) {
            Object.values(roomData.sets).forEach(set => {
              set.emoticons.forEach(emote => {
                emotesData.ffz.channel[emote.name] = {
                  id: emote.id,
                  url: `https://cdn.frankerfacez.com/emote/${emote.id}/2`,
                  url2x: `https://cdn.frankerfacez.com/emote/${emote.id}/4`,
                  width: emote.width,
                  height: emote.height,
                  zero_width: emote.css?.includes('transform') || false
                };
              });
            });
          }
        } catch (e) {}
      }

      const badgesDataFfz = await smartFetch("https://api.frankerfacez.com/v1/badges");
      if (badgesDataFfz.badges) {
        badgesDataFfz.badges.forEach(badge => {
          badgesData.ffz[badge.id] = {
            name: badge.name,
            url: `https://cdn.frankerfacez.com/badge/${badge.id}/2`,
            color: badge.color
          };
        });
        if (badgesDataFfz.users) {
          Object.entries(badgesDataFfz.users).forEach(([badgeId, users]) => {
            users.forEach(username => {
              if (!badgesData.ffz[username]) badgesData.ffz[username] = [];
              badgesData.ffz[username].push(badgeId);
            });
          });
        }
      }
    } catch (e) {
      console.warn("FFZ data load error:", e);
    }
  }

  // ============ LOAD BTTV EMOTES & BADGES ============
  async function loadBTTVData(twitchId = null) {
    try {
      const globalData = await smartFetch("https://api.betterttv.net/3/cached/emotes/global");
      globalData.forEach(emote => {
        emotesData.bttv.global[emote.code] = {
          id: emote.id,
          url: `https://cdn.betterttv.net/emote/${emote.id}/2x`,
          url2x: `https://cdn.betterttv.net/emote/${emote.id}/3x`,
          zero_width: emote.modifier || false
        };
      });

      if (twitchId) {
        try {
          const channelData = await smartFetch(`https://api.betterttv.net/3/cached/users/twitch/${twitchId}`);
          if (channelData.channelEmotes) {
            channelData.channelEmotes.forEach(emote => {
              emotesData.bttv.channel[emote.code] = {
                id: emote.id,
                url: `https://cdn.betterttv.net/emote/${emote.id}/2x`,
                url2x: `https://cdn.betterttv.net/emote/${emote.id}/3x`,
                zero_width: false
              };
            });
          }
          if (channelData.sharedEmotes) {
            channelData.sharedEmotes.forEach(emote => {
              emotesData.bttv.shared[emote.code] = {
                id: emote.id,
                url: `https://cdn.betterttv.net/emote/${emote.id}/2x`,
                url2x: `https://cdn.betterttv.net/emote/${emote.id}/3x`,
                zero_width: false
              };
            });
          }
        } catch (e) {}
      }

      const badgesDataBttv = await smartFetch("https://api.betterttv.net/3/cached/badges");
      badgesDataBttv.forEach(badge => {
        badgesData.bttv[badge.id] = {
          name: badge.name,
          url: `https://cdn.betterttv.net/badge/${badge.id}/2x`,
          provider: badge.provider
        };
      });
    } catch (e) {
      console.warn("BTTV data load error:", e);
    }
  }

  // ============ LOAD 7TV GLOBAL + CHANNEL ============
  async function load7TVData(twitchId = null) {
    try {
      const globalData = await smartFetch("https://7tv.io/v3/emote-sets/global");
      if (globalData.emotes) {
        globalData.emotes.forEach(emote => {
          const host = emote.data.host;
          const file = host.files.find(f => f.format === 'WEBP') || host.files[0];
          if (!file) return;
          const code = emote.name;
          if (emotesData.seventv.global[code]) return;
          emotesData.seventv.global[code] = {
            id: emote.id,
            url: `https:${host.url}/${file.name}`,
            url2x: `https:${host.url}/${host.files[1]?.name || file.name}`,
            width: emote.data.width?.[0] || 32,
            height: emote.data.height?.[0] || 32,
            zero_width: emote.data.flags === 1 || emote.data.flags === 3
          };
        });
      }

      if (twitchId) {
        try {
          const userData = await smartFetch(`https://7tv.io/v3/users/twitch/${twitchId}`);
          if (userData.emote_set?.emotes) {
            userData.emote_set.emotes.forEach(emote => {
              const host = emote.data.host;
              const file = host.files.find(f => f.format === 'WEBP') || host.files[0];
              if (!file) return;
              const code = emote.name;
              emotesData.seventv.channel[code] = {
                id: emote.id,
                url: `https:${host.url}/${file.name}`,
                url2x: `https:${host.url}/${host.files[1]?.name || file.name}`,
                width: emote.data.width?.[0] || 32,
                height: emote.data.height?.[0] || 32,
                zero_width: emote.data.flags === 1 || emote.data.flags === 3
              };
            });
          }

          if (userData.user?.style?.paints) {
            userData.user.style.paints.forEach(paint => {
              namePaints[userData.user.id] = {
                name: paint.name,
                color: paint.color,
                gradient: paint.gradient,
                shadows: paint.shadows
              };
            });
          }
        } catch (e) {}
      }
    } catch (e) {
      console.warn("7TV global/channel load error:", e);
    }
  }

  // ============ NUEVO: LOAD 7TV COMMUNITY SETS PARA KICK ============
  async function load7TVCommunitySets() {
    statusMsg.textContent = "Cargando sets comunitarios de 7TV para Kick...";
    let totalLoaded = 0;

    for (const setId of KICK_7TV_COMMUNITY_SETS) {
      try {
        const data = await smartFetch(`https://7tv.io/v3/emote-sets/${setId}`);
        if (!data?.emotes?.length) continue;

        let setLoaded = 0;
        data.emotes.forEach(emote => {
          const host = emote.data.host;
          const file = host.files.find(f => f.format === 'WEBP') || host.files[0];
          if (!file) return;

          const code = emote.name;
          // Prioridad: no sobreescribir si ya existe en channel o global
          if (emotesData.seventv.channel[code] || emotesData.seventv.global[code]) return;

          emotesData.seventv.community[code] = {
            id: emote.id,
            url: `https:${host.url}/${file.name}`,
            url2x: `https:${host.url}/${host.files[1]?.name || file.name}`,
            width: emote.data.width?.[0] || 32,
            height: emote.data.height?.[0] || 32,
            zero_width: emote.data.flags === 1 || emote.data.flags === 3
          };
          setLoaded++;
          totalLoaded++;
        });

        console.log(`Set 7TV ${setId} â†’ ${setLoaded} emotes nuevos`);
      } catch (err) {
        console.warn(`Error cargando set 7TV ${setId}:`, err);
      }
    }

    console.log(`Total emotes 7TV comunitarios cargados: ${totalLoaded}`);
    if (totalLoaded > 0) {
      statusMsg.textContent += ` (${totalLoaded} emotes 7TV Kick cargados)`;
    }
  }

  // ============ LOAD CHATTERINO BADGES ============
  async function loadChatterinoBadges() {
    try {
      const data = await smartFetch("https://api.chatterino.com/badges");
      if (data.badges) {
        data.badges.forEach(badge => {
          badgesData.chatterino[badge.id] = {
            name: badge.tooltip,
            url: badge.image1,
            url2x: badge.image2,
            users: badge.users || []
          };
          badge.users?.forEach(username => {
            const key = username.toLowerCase();
            if (!badgesData.chatterino[key]) badgesData.chatterino[key] = [];
            badgesData.chatterino[key].push(badge.id);
          });
        });
      }
    } catch (e) {
      console.warn("Chatterino badges load error:", e);
    }
  }

  // ============ LOAD FFZ:AP BADGES ============
  async function loadFFZAPBadges() {
    try {
      const data = await smartFetch("https://api-test.frankerfacez.com/badges");
      if (data.badges) {
        data.badges.forEach(badge => {
          badgesData.ffzap[badge.id] = {
            name: badge.name,
            url: badge.urls?.['2'] || badge.urls?.['1'],
            color: badge.color
          };
        });
        if (data.users) {
          Object.entries(data.users).forEach(([badgeId, users]) => {
            users.forEach(username => {
              const key = username.toLowerCase();
              if (!badgesData.ffzap[key]) badgesData.ffzap[key] = [];
              badgesData.ffzap[key].push(parseInt(badgeId));
            });
          });
        }
      }
    } catch (e) {
      console.warn("FFZ:AP badges load error:", e);
    }
  }

  // ============ LOAD ALL THIRD PARTY DATA ============
  async function loadAllThirdPartyData(twitchId = null) {
    statusMsg.textContent = "Cargando emotes y badges de terceros (incluyendo 7TV Kick)...";
    
    await Promise.all([
      loadFFZData(twitchId),
      loadBTTVData(twitchId),
      load7TVData(twitchId),
      load7TVCommunitySets(),
      loadChatterinoBadges(),
      loadFFZAPBadges()
    ]);
    
    console.log("Emotes cargados total:", {
      ffz: Object.keys(emotesData.ffz.global).length + Object.keys(emotesData.ffz.channel).length,
      bttv: Object.keys(emotesData.bttv.global).length + Object.keys(emotesData.bttv.channel).length + Object.keys(emotesData.bttv.shared).length,
      seventv: Object.keys(emotesData.seventv.global).length + 
               Object.keys(emotesData.seventv.channel).length + 
               Object.keys(emotesData.seventv.community).length
    });
  }

  // ============ PROCESS EMOTES (prioridad: channel > community > global) ============
  function processEmotes(text, zeroWidthEmotes = []) {
    if (!text) return "";
    
    let result = text.replace(/\[emote:(\d+):([^\]]+)\]/g, (_, id, nombre) => {
      return `<img src="https://files.kick.com/emotes/${id}/fullsize" alt="${nombre}" title="${nombre}" class="emote">`;
    });

    const allEmotes = {
      ...emotesData.seventv.channel,      // 1. Canal (si llega a cargar)
      ...emotesData.seventv.community,    // 2. Sets comunitarios Kick (lo principal)
      ...emotesData.seventv.global,       // 3. Globales 7TV
      ...emotesData.bttv.channel,
      ...emotesData.bttv.shared,
      ...emotesData.bttv.global,
      ...emotesData.ffz.channel,
      ...emotesData.ffz.global
    };

    const sortedEmotes = Object.entries(allEmotes).sort((a, b) => b[0].length - a[0].length);

    sortedEmotes.forEach(([code, emote]) => {
      const regex = new RegExp(`\\b${escapeRegex(code)}\\b`, 'g');
      const isZeroWidth = emote.zero_width;
      
      result = result.replace(regex, (match) => {
        return `<img src="${emote.url}" srcset="${emote.url} 1x, ${emote.url2x || emote.url} 2x" alt="${code}" title="${code}" class="emote${isZeroWidth ? ' emote-zero-width' : ''}">`;
      });
    });

    return result;
  }

  function escapeRegex(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  // ============ GENERATE BADGES ============
  function generateBadges(m) {
    const badges = m.identity?.badges || m.sender?.identity?.badges || [];
    const username = (m.sender?.username || "AnÃ³nimo").toLowerCase();
    const userId = m.sender?.id;
    
    let badgeHtml = "";

    if (Array.isArray(badges)) {
      badges.forEach(b => {
        const tipo = b.type?.toLowerCase();
        const icon = KICK_BADGES[tipo];
        if (icon) {
          badgeHtml += `<img src="${icon}" alt="${tipo}" title="${b.text || tipo}" class="badge-icon">`;
        }
      });
    }

    const seventvUserBadges = badgesData.seventv[`tw:${userId}`] || badgesData.seventv[username] || [];
    seventvUserBadges.forEach(badgeId => {
      const badge = badgesData.seventv[badgeId];
      if (badge) {
        badgeHtml += `<img src="${badge.url}" alt="${badge.name}" title="${badge.tooltip || badge.name}" class="badge-icon" style="border-radius: 4px;">`;
      }
    });

    const ffzUserBadges = badgesData.ffz[username] || [];
    ffzUserBadges.forEach(badgeId => {
      const badge = badgesData.ffz[badgeId];
      if (badge && typeof badge === 'object' && badge.url) {
        badgeHtml += `<img src="${badge.url}" alt="${badge.name}" title="${badge.name}" class="badge-icon">`;
      }
    });

    const chatterinoUserBadges = badgesData.chatterino[username] || [];
    chatterinoUserBadges.forEach(badgeId => {
      const badge = badgesData.chatterino[badgeId];
      if (badge && typeof badge === 'object') {
        badgeHtml += `<img src="${badge.url2x || badge.url}" alt="${badge.name}" title="${badge.name}" class="badge-icon">`;
      }
    });

    const ffzapUserBadges = badgesData.ffzap[username] || [];
    ffzapUserBadges.forEach(badgeId => {
      const badge = badgesData.ffzap[badgeId];
      if (badge && typeof badge === 'object' && badge.url) {
        badgeHtml += `<img src="${badge.url}" alt="${badge.name}" title="${badge.name}" class="badge-icon">`;
      }
    });

    return badgeHtml;
  }

  // ============ GENERATE NAME PAINT ============
  function generateNamePaint(m) {
    const userId = m.sender?.id;
    const username = m.sender?.username || "AnÃ³nimo";
    const baseColor = m.identity?.color || m.sender?.identity?.color || "#00ff66";
    
    const paint = namePaints[userId];
    
    if (paint) {
      let style = "";
      if (paint.gradient) {
        const stops = paint.gradient.stops.map(s => `${s.color} ${s.at * 100}%`).join(', ');
        style = `background: linear-gradient(${paint.gradient.angle}deg, ${stops}); background-clip: text; -webkit-background-clip: text; -webkit-text-fill-color: transparent;`;
      } else if (paint.color) {
        style = `color: ${paint.color};`;
      }
      
      if (paint.shadows && paint.shadows.length > 0) {
        const shadowStyle = paint.shadows.map(s => {
          if (s.type === 'drop') {
            return `drop-shadow(${s.x_offset}px ${s.y_offset}px ${s.radius}px ${s.color})`;
          }
          return '';
        }).join(' ');
        style += ` filter: ${shadowStyle};`;
      }
      
      return style || `color: ${baseColor};`;
    }
    
    return `color: ${baseColor};`;
  }

  // ============ MAIN FUNCTIONS ============
  async function getChannelId(channelSlug) {
    statusMsg.textContent = "Obteniendo informaciÃ³n del canal...";
    statusMsg.style.color = "#53fc18";
    
    try {
      const apiUrl = `https://kick.com/api/v1/channels/${channelSlug}`;
      const data = await smartFetch(apiUrl);
      
      const isLive = data.livestream && data.livestream.id;
      const channelId = data.id;
      const chatroomId = data.chatroom?.id;
      
      return { 
        channelId: channelId,
        chatroomId: chatroomId,
        isLive: isLive,
        channelData: data
      };
    } catch (err) {
      statusMsg.textContent = "Error: " + err.message;
      statusMsg.style.color = "#ff4444";
      throw err;
    }
  }

  async function loadChat() {
    const channelName = channelInput.value.trim().toLowerCase();
    
    if (!channelName) {
      statusMsg.textContent = "Por favor, ingresa un nombre de canal";
      statusMsg.style.color = "#ff4444";
      return;
    }
    
    try {
      const result = await getChannelId(channelName);
      CHANNEL_ID = result.channelId;
      CHATROOM_ID = result.chatroomId;
      currentChannel = channelName;
      CHAT_URL = `https://kick.com/api/v2/channels/${CHANNEL_ID}/messages`;
      
      await loadAllThirdPartyData();
      
      const isChatOnlyMode = getUrlParams() !== null;
      
      if (isChatOnlyMode) {
        inputContainer.style.display = "none";
        chatDiv.style.display = "flex";
      } else {
        if (result.isLive) {
          statusMsg.textContent = `ðŸ”´ EN VIVO: ${channelName} (WebSocket Real-Time)`;
          statusMsg.style.color = "#53fc18";
        } else {
          statusMsg.textContent = `âš« OFFLINE: ${channelName} - Esperando mensajes...`;
          statusMsg.style.color = "#ffaa00";
        }
        
        const link = generateLink(channelName);
        generatedLink.value = link;
        linkContainer.style.display = "block";
        
        channelInput.style.display = "none";
        loadBtn.style.display = "none";
        chatDiv.style.display = "flex";
      }
      
      chatDiv.innerHTML = "";
      messageIds.clear();
      
      connectWebSocket();
      fetchInitialMessages();
    } catch (err) {
      console.error("Error:", err);
    }
  }

  function connectWebSocket() {
    if (kickWS) {
      kickWS.close();
    }
    
    kickWS = new WebSocket(PUSHER_WS_URL);
    
    kickWS.addEventListener("open", () => {
      console.log("WebSocket conectado a Pusher");
      kickWS.send(JSON.stringify({
        event: "pusher:subscribe",
        data: { auth: "", channel: `chatrooms.${CHATROOM_ID}.v2` }
      }));
    });
    
    kickWS.addEventListener("message", (event) => {
      try {
        const messageData = JSON.parse(event.data);
        
        if (messageData.event === "App\\Events\\ChatMessageEvent") {
          const chatMessageData = JSON.parse(messageData.data);
          handleChatMessage(chatMessageData);
        }
        
        if (messageData.event === "App\\Events\\MessageDeletedEvent") {
          const deleteData = JSON.parse(messageData.data);
          removeMessage(deleteData.message.id);
        }
        
        if (messageData.event === "App\\Events\\UserBannedEvent") {
          const banData = JSON.parse(messageData.data);
          removeUserMessages(banData.user.id);
        }
      } catch (err) {}
    });
    
    kickWS.addEventListener("error", () => {
      console.log("WebSocket error, reconectando...");
      setTimeout(connectWebSocket, 1000);
    });
    
    kickWS.addEventListener("close", () => {
      console.log("WebSocket cerrado, reconectando...");
      setTimeout(connectWebSocket, 1000);
    });
  }

  function handleChatMessage(data) {
    if (messageIds.has(data.id)) return;
    messageIds.add(data.id);
    
    const message = {
      id: data.id,
      content: data.content,
      sender: {
        id: data.sender.id,
        username: data.sender.username,
        identity: {
          color: data.sender.identity?.color || "#00ff66",
          badges: data.sender.identity?.badges || []
        }
      },
      identity: data.sender.identity
    };
    
    addMessage(message);
  }

  function removeMessage(messageId) {
    const msgElement = document.getElementById(messageId);
    if (msgElement) msgElement.remove();
  }

  function removeUserMessages(userId) {
    document.querySelectorAll(`[data-user-id="${userId}"]`).forEach(msg => msg.remove());
  }

  async function fetchInitialMessages() {
    if (!CHAT_URL) return;
    
    try {
      const data = await raceFetch(CHAT_URL);
      let messages = data?.data?.messages || data?.messages || [];
      
      if (messages && messages.length > 0) {
        messages.reverse().forEach(m => {
          if (!messageIds.has(m.id)) {
            messageIds.add(m.id);
            addMessage(m);
          }
        });
      }
    } catch (err) {}
  }

  copyLinkBtn.addEventListener("click", async () => {
    try {
      await navigator.clipboard.writeText(generatedLink.value);
      copyLinkBtn.textContent = "Copiado!";
      setTimeout(() => { copyLinkBtn.textContent = "ðŸ“‹ Copiar"; }, 2000);
    } catch (err) {
      generatedLink.select();
      document.execCommand("copy");
      copyLinkBtn.textContent = "Copiado!";
      setTimeout(() => { copyLinkBtn.textContent = "ðŸ“‹ Copiar"; }, 2000);
    }
  });

  openLinkBtn.addEventListener("click", () => {
    window.open(generatedLink.value, "_blank");
  });

  loadBtn.addEventListener("click", loadChat);
  channelInput.addEventListener("keypress", (e) => {
    if (e.key === "Enter") loadChat();
  });

  window.addEventListener("DOMContentLoaded", () => {
    const channelParam = getUrlParams();
    if (channelParam) {
      channelInput.value = channelParam;
      loadChat();
    }
  });

  function addMessage(m) {
    const username = m.sender?.username || "AnÃ³nimo";
    const userId = m.sender?.id || "";
    const messageId = m.id || "";
    const badgesHTML = generateBadges(m);
    const nameStyle = generateNamePaint(m);
    const processedContent = processEmotes(m.content);
    
    const msg = document.createElement("div");
    msg.className = "msg";
    msg.id = messageId;
    msg.setAttribute("data-user-id", userId);
    msg.innerHTML = `<span class="meta"><span class="user" style="${nameStyle}">${badgesHTML}${username}</span></span><span class="text">${processedContent}</span>`;
    chatDiv.appendChild(msg);
    chatDiv.scrollTop = chatDiv.scrollHeight;
  }
</script>

</body>
</html>